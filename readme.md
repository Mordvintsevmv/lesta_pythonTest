# Тестовое задание для отклика на вакансию "Junior Python Programmer (стажер)" 

__*Python 2.7*__

---

## Задания:

### 1. Чётность числа
На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.


```python
def isEven(value):return value%2==0
```

### 2. Циклический буфер FIFO
На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

### 3. Сортировка массива
На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.

---

## Решения:

### 1. Чётность числа

#### Реализация
Была реализована следующая функция:

```python
def myEven(value):
    return value & 1 == 0
```

---

#### Принцип работы


Функция основана на битовой операции И (AND)

---

Например, 5 в бинарной системе – __101__

Выполнение операции И с 1 (001)

101 И 001  = 001 (1) - число нечётное

---
4 в бинарной системе – __100__

Выполнение операции И с 1 (001)

100 И 001  = 000 (0) - число чётное

---

#### Скорость работы

В ходе тестирования было выявлено, что в среднем моя функция работает быстрее: 
```
Моя функция чётности: 9.53674316406e-07
Не моя функция чётности: 1.90734863281e-06
```


---

#### Плюсы и минусы


✅Очень эффективно работает с целыми числами любых размеров

❌Не подходит для дробных чисел

---

В целом обе функции работают достаточно эффективно с целыми числами, поэтому их использование зависит от предпочтений разработчика и условий выполняемых задач.

---

### 2. Циклический буфер FIFO

#### Реализация

Так как сама концепция циклического буфера на языке Python не позволяет раелизовать множество различных вариантов (например, нет указателей как в C++), было решено создать два циклических буфера:

1. С использованием дополнительной переменной cursize, которая позволяет подсчитать количество элементов в буфере.
2. Без использования дополнительной переменной подсчёта.

---

У классов были реализованы:

 1. Конструктор, который принимает размер буфера
 2. Функция конвертации буфера в строку (для дальнейшего вывода) (возвращает строку)
 3. Функция push для добавления элемента в конец очереди
 4. Функция pop для извлечения элемента из начала очереди (возвращает элемент буфера)
 5. Функция isEmpty для проверки пустого буфера (возвращается bool)
 6. Функция isFull для проверки полного буфера (возвращается bool)
 7. Функция printQueue для печати буфера
 8. Функция length для получения длины (возвращает длину буфера)
 9. Функция clear для полной очистки буфера

---

#### Плюсы и минусы

В целом данные буферы максимально схожи в реализации. 

Можно выделить сэкономленную память второго буфера, так как не создаётся отдельная переменная под размер заполненнного массива.

---

### 3. Сортировка массива

#### Реализация

Для большинства рядовых задач по сортировке обычного массива из целых чисел чаще всего используется __Быстрая сортировка__.

Метод быстрой сортировки рекурсивно основан на рекурсивном вызове функции сортировки.

В начале выбирается случайное число из массива. Далее все значения массива делятся на 3 массива:

1. Числа, меньше выбранного
2. Числа, равные выбранному
3. Числа, больше выбранного

Далее для каждого массива снова вызывается функция сортировки, где все действия повторяются.

В итоге полученные массивы склеиваются в нужном порядке.

---

Также было решено протестировать метод __сортировки подсчётом__, который считает количество вхождений каждого элемента.

---

#### Скорость работы

В ходе тестирования было выявлено, что функция сортировки подсчётом работает в разы эффективнее при числах, менее ~60000 (на моём устройстве).
```
Быстрая (маленькие числа): 0.359293937683
Подсчёт (маленькие числа): 0.0384709835052
```

Тем не менее скорость работы сортировки подсчётом резко падает, если массив содержит крупные числа:
```
Быстрая (большие числа): 0.196753978729
Подсчёт (большие числа): 1.85210299492
```

При этом скорость работы быстрого алгоритма сортировки в среднем остаётся неизменной.

---

Это связано с тем, что в среднем сложность быстрого алгоритма – __O(n * log(n))__

В то время как сложность алгоритма подсчётом – __O(n+k), где n — количество элементов, а k — максимальное значение элемента__

---

Таким образом, быстрый алгоритм сортировки универсален и подойдёт для любых массивов.

Сортировка методом подсчёта будет эффективно только в том случае, если ей передаётся массив из относительно небольших чисел

---

## Контакты

**TG**: @mordvintsevmv

**e-mail**: mordvintsevmv@gmail.com
